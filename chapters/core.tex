\chapter{Core}
\label{cha:core}

\section{Migration to Rust}
\label{cha:Migration to Rust} During and after all the development described in
the previous steps, there was the idea of trying to write all the logic of the toolchain
in Rust. Empirically, Rust is a more performant language confronted to Python,
it offers a lot of security features, and it is increasing in popularity.
Therefore, switching from a pure Python implementation to a Rust one seemed the most
logical choice. I started to make some research about how the Rust code could be
integrated and if ultimately, this was even a good idea. It turned out that it
was not, for this specific codebase. But let's see why. First, lets focus deeply
on the eventual pros that switching to Rust could have brought.

\subsection[short]{Eventual pros}
As said before, Rust is way more performant than Python. Naturally, for the majority
of the tasks, it runs on three orders of magnitude faster than Python. This due to
his lower-level nature. Rust is also a safer language, with a lot of features that
prevent the developer from making mistakes. The borrow checker can be a pain
during development, but assures that a lot of error never happen. Rust is also a
language that has the potential to be more maintainable and extensible. This could
be made by defining base traits (the Rust interfaces, but more powerful) to, in the
future, being able to insert new parser if needed.

\subsection[short]{Cons 1: Modularization}
It would have been a huge win if all the heavy lifting could be made by the Rust
code instead of the actual Python one. Looking at the codebase, it was clear
that that was not possible. This is because the codebase does not allow for modular
development. This is because a lot of the code relies on sharing some global
variables, that all the steps share. Also, there are external libraries called at
each step, so that code was not upgradable to Rust. In the end, it made no sense
to modularize the entire pipeline in one unique Rust codebase, since it was called
at each step of the pipeline in an independent way. This meant that, in order to
switch, we had to create a lot of different Rust microservices, and call each one
of them via bindings, and then also re-elaboreate the output, to be compatible with
the Python code. This would have been a huge amount of work, and it would have been
a source of bugs and technological debt. This, will turn out in one of following
subsections, was the ultimate reson also for not having any substantial
performance gain.

\subsection[short]{Cons 2: Libraries support}
As the time of writing, there is no robust and stable library for parsing written
in Rust. This meant that I needed to write a parser library from scratch. This has
been done, via a small proof of concept. The library is called Pilator, and its
only capability, at the moment, is allowing users to define their own Regex-like
language, and parse the strings with it. It is done with a simple backtracking
algorithm, and it is not optimized. It was just to see if there was any
potential in this path. The library is available on GitHub (\cite{pilator}).
Wrinting this library has highlighted the fact that writing this is a whole
project in itself, with a lot of complexity, bugs, edge cases and optimizations to
be made. This was only a source of technological debt for the codebase. If a bug
was to be discovered and year from the time of writing, there was anyone
maintaining and fixing the library, and the whole project would be stuck.

\subsection[short]{Cons 3: Real performance}
The second problem with this implementation is that the main code is still written
in Python, therefore we needed to modularize each component of the pipeline in
itself. We could not switch it entirely and then call directly the Rust code.
This brings the bottleneck of the bindings needed to communicate between the
Python and the Rust code. To check if, performace-wise, this could make sense anyway,
I set up a small test. By writing with bindings, simply a function sums two
numbers in Rust, using the Maturing Py03 Library, the most known and developed
library for this purpose. To do just so, it takes around 10 seconds for each
compile, and 11 nanoseconds to sum two numbers. Python to do a simple sum takes
around 30 nanoseconds. I also decided to test the performance of the existing Python
code for parsing. It turns out that it takes and average of 3 milliseconds to
parse a single line of BIR language. This means that, in a system where it will
be rare that there will be more than 1000 lines of BIR code, the parser does not
really represent a bottleneck, given the fact that we are using Rosette to
generate new code, and continuously calling the solver. According to this number,
and the fact that the library we would be using would not be as optimized as the
Python one (`pyparsing`), the performance gain would be minimal, if not negative.
And all would cost huge amount of time for developing and debugging a new
solution from scratch.

All the benchmark code can be found on GitHub (\cite{benchmark}).

\subsection[short]{Cons 4: Real extensibility}
Another point that I made about switching to Rust was the eventual extensibility
of the produced code, allowing for future new parser and eventual. If we created
a `parser` trait, then any eventual additional language could have been the same
trait, and therefore, once tested there was no need in the actual code to handle
the new addition. This is a really useful feature, if you ever use it.

As we thought, the scope of this thesis was creating a new pipeline to handle
the BIR language, that was more robust and researched for representing a ISA of a
real CPU. How many other times there will be the need to implement a new
language for the ISA? Probably never. There are not even much other candidate to
do so, and BIR seems to be, as today, the best. Therefore, the extensibility of the
codebase was not a real concern, and it was not worth the effort to switch to
Rust for this reason.

\subsection[short]{Cons 5: Development speed}
Another fact is that, compared to Python, Rust is way slower to develop. This is
because of the borrow checker, that is a really powerful tool, but it can be a pain
to work with. In this case, development performance is more important, since
this is a research project. So, beigng able to do things and destroy afterwards,
without spending astonishing amount of times was a huge win, and for this Python
was just the best. Plus, on the team there was no high expertise in Rust. This would
have meant technical debt to be paid in the future, and a lot of time spent on
learning the language. Given the type of project in itself, this was not worth
the effort.

\subsection[short]{Cons 6: Safety}
One last point is on safety. This could be a deal-breaker for some cases, where
the codebase is really critical. But in this case, the codebase is not critical,
and it is used to synthesize contracts from the CPU, from a local computer. This
means no huge throughput, not real race conditions, and probably not real issues
at all with memory management.

Ultimately, the safety that Rust would have naturally given to the codebase, was
not something that was stricly required, nor even much useful.